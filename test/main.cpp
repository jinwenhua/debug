
#include "../src/debugserver.h"
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <direct.h>  
#include "luawrapper.h"
#include "../src/debug_dll.h"

#if !defined(LUA_PROGNAME)
#define LUA_PROGNAME		"lua"
#endif

static lua_State *globalL = NULL;
static const char *progname = LUA_PROGNAME;

/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop(lua_State *L, lua_Debug *ar) {
	(void)ar;  /* unused arg. */
	lua_sethook(L, NULL, 0, 0);  /* reset hook */
	luaL_error(L, "interrupted!");
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char *pname, const char *msg) {
	if (pname) lua_writestringerror("%s: ", pname);
	lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report(lua_State *L, int status) {
	if (status != LUA_OK) {
		const char *msg = lua_tostring(L, -1);
		l_message(progname, msg);
		lua_pop(L, 1);  /* remove message */
	}
	return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State *L) {
	const char *msg = lua_tostring(L, 1);
	if (msg == NULL) {  /* is error object not a string? */
		if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
			lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
			return 1;  /* that is the message */
		else
			msg = lua_pushfstring(L, "(error object is a %s value)",
				luaL_typename(L, 1));
	}
	luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
	return 1;  /* return the traceback */
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction(int i) {
	signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
	lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}


/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall(lua_State *L, int narg, int nres) {
	int status;
	int base = lua_gettop(L) - narg;  /* function index */
	lua_pushcfunction(L, msghandler);  /* push message handler */
	lua_insert(L, base);  /* put it under function and args */
	globalL = L;  /* to be available to 'laction' */
	signal(SIGINT, laction);  /* set C-signal handler */
	status = lua_pcall(L, narg, nres, base);
	signal(SIGINT, SIG_DFL); /* reset C-signal handler */
	lua_remove(L, base);  /* remove message handler from the stack */
	return status;
}

static int handle_script(lua_State *L, const char *fname) {
	int status;
	status = luaL_loadfile(L, fname);
	if (status == LUA_OK) {
		//int n = pushargs(L);  /* push arguments to script */
		status = docall(L, 0, LUA_MULTRET);
	}
	return report(L, status);
}

int pmain(lua_State* luaEnv)
{
    luaL_openlibs(luaEnv);
	L_LUA_WRAPPER_REGISTER(DebugServerWrapper, luaEnv);
	char *buffer;
	char path[256] = { 0 };
	int running = 1;
	//也可以将buffer作为输出参数  
	if ((buffer = getcwd(NULL, 0)) == NULL)
	{
		perror("getcwd error\n");
	}
	else
	{
		sprintf(path, "%s\\test.lua", buffer);
        path[254] = 0;
		printf("file: %s\n", buffer);
		free(buffer);
	}

    if(handle_script(luaEnv, path) != LUA_OK)
    {
        printf("error pcall:\n %s\n", luaL_tolstring(luaEnv, -1, NULL));
		return 0;
    }

	while (running == 1)
	{
		lua_getglobal(luaEnv, "on_tick");
		docall(luaEnv, 0, 1);
		running = luaL_checkint(luaEnv, -1);
		lua_pop(luaEnv, -1);
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    lua_close(luaEnv);
	printf("press any key to exit.\n");
    getchar();
    return 0;
}

int main(int argc, char **argv) {
	int status, result;
	lua_State *L = luaL_newstate();  /* create state */
	if (L == NULL) {
		l_message(argv[0], "cannot create state: not enough memory");
		return EXIT_FAILURE;
	}
	lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
	lua_pushinteger(L, argc);  /* 1st argument */
	lua_pushlightuserdata(L, argv); /* 2nd argument */
	status = lua_pcall(L, 2, 1, 0);  /* do the call */
	result = lua_toboolean(L, -1);  /* get result */
	report(L, status);
	lua_close(L);
	return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}




